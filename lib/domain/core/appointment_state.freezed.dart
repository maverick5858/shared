// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'appointment_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AppointmentState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppointmentStateCopyWith<$Res> {
  factory $AppointmentStateCopyWith(
          AppointmentState value, $Res Function(AppointmentState) then) =
      _$AppointmentStateCopyWithImpl<$Res, AppointmentState>;
}

/// @nodoc
class _$AppointmentStateCopyWithImpl<$Res, $Val extends AppointmentState>
    implements $AppointmentStateCopyWith<$Res> {
  _$AppointmentStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PendingImplCopyWith<$Res> {
  factory _$$PendingImplCopyWith(
          _$PendingImpl value, $Res Function(_$PendingImpl) then) =
      __$$PendingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PendingImplCopyWithImpl<$Res>
    extends _$AppointmentStateCopyWithImpl<$Res, _$PendingImpl>
    implements _$$PendingImplCopyWith<$Res> {
  __$$PendingImplCopyWithImpl(
      _$PendingImpl _value, $Res Function(_$PendingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PendingImpl implements Pending {
  const _$PendingImpl();

  @override
  String toString() {
    return 'AppointmentState.pending()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PendingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) {
    return pending();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) {
    return pending?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) {
    return pending(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) {
    return pending?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending(this);
    }
    return orElse();
  }
}

abstract class Pending implements AppointmentState {
  const factory Pending() = _$PendingImpl;
}

/// @nodoc
abstract class _$$ConfirmedImplCopyWith<$Res> {
  factory _$$ConfirmedImplCopyWith(
          _$ConfirmedImpl value, $Res Function(_$ConfirmedImpl) then) =
      __$$ConfirmedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConfirmedImplCopyWithImpl<$Res>
    extends _$AppointmentStateCopyWithImpl<$Res, _$ConfirmedImpl>
    implements _$$ConfirmedImplCopyWith<$Res> {
  __$$ConfirmedImplCopyWithImpl(
      _$ConfirmedImpl _value, $Res Function(_$ConfirmedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConfirmedImpl implements Confirmed {
  const _$ConfirmedImpl();

  @override
  String toString() {
    return 'AppointmentState.confirmed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConfirmedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) {
    return confirmed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) {
    return confirmed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) {
    if (confirmed != null) {
      return confirmed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) {
    return confirmed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) {
    return confirmed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) {
    if (confirmed != null) {
      return confirmed(this);
    }
    return orElse();
  }
}

abstract class Confirmed implements AppointmentState {
  const factory Confirmed() = _$ConfirmedImpl;
}

/// @nodoc
abstract class _$$ActiveImplCopyWith<$Res> {
  factory _$$ActiveImplCopyWith(
          _$ActiveImpl value, $Res Function(_$ActiveImpl) then) =
      __$$ActiveImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ActiveImplCopyWithImpl<$Res>
    extends _$AppointmentStateCopyWithImpl<$Res, _$ActiveImpl>
    implements _$$ActiveImplCopyWith<$Res> {
  __$$ActiveImplCopyWithImpl(
      _$ActiveImpl _value, $Res Function(_$ActiveImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ActiveImpl implements Active {
  const _$ActiveImpl();

  @override
  String toString() {
    return 'AppointmentState.active()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ActiveImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) {
    return active();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) {
    return active?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) {
    if (active != null) {
      return active();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) {
    return active(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) {
    return active?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) {
    if (active != null) {
      return active(this);
    }
    return orElse();
  }
}

abstract class Active implements AppointmentState {
  const factory Active() = _$ActiveImpl;
}

/// @nodoc
abstract class _$$OngoingImplCopyWith<$Res> {
  factory _$$OngoingImplCopyWith(
          _$OngoingImpl value, $Res Function(_$OngoingImpl) then) =
      __$$OngoingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OngoingImplCopyWithImpl<$Res>
    extends _$AppointmentStateCopyWithImpl<$Res, _$OngoingImpl>
    implements _$$OngoingImplCopyWith<$Res> {
  __$$OngoingImplCopyWithImpl(
      _$OngoingImpl _value, $Res Function(_$OngoingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OngoingImpl implements Ongoing {
  const _$OngoingImpl();

  @override
  String toString() {
    return 'AppointmentState.ongoing()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OngoingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) {
    return ongoing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) {
    return ongoing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) {
    if (ongoing != null) {
      return ongoing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) {
    return ongoing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) {
    return ongoing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) {
    if (ongoing != null) {
      return ongoing(this);
    }
    return orElse();
  }
}

abstract class Ongoing implements AppointmentState {
  const factory Ongoing() = _$OngoingImpl;
}

/// @nodoc
abstract class _$$MissedImplCopyWith<$Res> {
  factory _$$MissedImplCopyWith(
          _$MissedImpl value, $Res Function(_$MissedImpl) then) =
      __$$MissedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MissedImplCopyWithImpl<$Res>
    extends _$AppointmentStateCopyWithImpl<$Res, _$MissedImpl>
    implements _$$MissedImplCopyWith<$Res> {
  __$$MissedImplCopyWithImpl(
      _$MissedImpl _value, $Res Function(_$MissedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MissedImpl implements Missed {
  const _$MissedImpl();

  @override
  String toString() {
    return 'AppointmentState.missed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MissedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) {
    return missed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) {
    return missed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) {
    if (missed != null) {
      return missed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) {
    return missed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) {
    return missed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) {
    if (missed != null) {
      return missed(this);
    }
    return orElse();
  }
}

abstract class Missed implements AppointmentState {
  const factory Missed() = _$MissedImpl;
}

/// @nodoc
abstract class _$$RequestForRescheduleImplCopyWith<$Res> {
  factory _$$RequestForRescheduleImplCopyWith(_$RequestForRescheduleImpl value,
          $Res Function(_$RequestForRescheduleImpl) then) =
      __$$RequestForRescheduleImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RequestForRescheduleImplCopyWithImpl<$Res>
    extends _$AppointmentStateCopyWithImpl<$Res, _$RequestForRescheduleImpl>
    implements _$$RequestForRescheduleImplCopyWith<$Res> {
  __$$RequestForRescheduleImplCopyWithImpl(_$RequestForRescheduleImpl _value,
      $Res Function(_$RequestForRescheduleImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RequestForRescheduleImpl implements RequestForReschedule {
  const _$RequestForRescheduleImpl();

  @override
  String toString() {
    return 'AppointmentState.requestForReschedule()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RequestForRescheduleImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) {
    return requestForReschedule();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) {
    return requestForReschedule?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) {
    if (requestForReschedule != null) {
      return requestForReschedule();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) {
    return requestForReschedule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) {
    return requestForReschedule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) {
    if (requestForReschedule != null) {
      return requestForReschedule(this);
    }
    return orElse();
  }
}

abstract class RequestForReschedule implements AppointmentState {
  const factory RequestForReschedule() = _$RequestForRescheduleImpl;
}

/// @nodoc
abstract class _$$PartiallyCompletedImplCopyWith<$Res> {
  factory _$$PartiallyCompletedImplCopyWith(_$PartiallyCompletedImpl value,
          $Res Function(_$PartiallyCompletedImpl) then) =
      __$$PartiallyCompletedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PartiallyCompletedImplCopyWithImpl<$Res>
    extends _$AppointmentStateCopyWithImpl<$Res, _$PartiallyCompletedImpl>
    implements _$$PartiallyCompletedImplCopyWith<$Res> {
  __$$PartiallyCompletedImplCopyWithImpl(_$PartiallyCompletedImpl _value,
      $Res Function(_$PartiallyCompletedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PartiallyCompletedImpl implements PartiallyCompleted {
  const _$PartiallyCompletedImpl();

  @override
  String toString() {
    return 'AppointmentState.partiallyCompleted()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PartiallyCompletedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) {
    return partiallyCompleted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) {
    return partiallyCompleted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) {
    if (partiallyCompleted != null) {
      return partiallyCompleted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) {
    return partiallyCompleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) {
    return partiallyCompleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) {
    if (partiallyCompleted != null) {
      return partiallyCompleted(this);
    }
    return orElse();
  }
}

abstract class PartiallyCompleted implements AppointmentState {
  const factory PartiallyCompleted() = _$PartiallyCompletedImpl;
}

/// @nodoc
abstract class _$$CompletedImplCopyWith<$Res> {
  factory _$$CompletedImplCopyWith(
          _$CompletedImpl value, $Res Function(_$CompletedImpl) then) =
      __$$CompletedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CompletedImplCopyWithImpl<$Res>
    extends _$AppointmentStateCopyWithImpl<$Res, _$CompletedImpl>
    implements _$$CompletedImplCopyWith<$Res> {
  __$$CompletedImplCopyWithImpl(
      _$CompletedImpl _value, $Res Function(_$CompletedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CompletedImpl implements Completed {
  const _$CompletedImpl();

  @override
  String toString() {
    return 'AppointmentState.completed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CompletedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) {
    return completed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) {
    return completed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class Completed implements AppointmentState {
  const factory Completed() = _$CompletedImpl;
}

/// @nodoc
abstract class _$$CancelledImplCopyWith<$Res> {
  factory _$$CancelledImplCopyWith(
          _$CancelledImpl value, $Res Function(_$CancelledImpl) then) =
      __$$CancelledImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CancelledImplCopyWithImpl<$Res>
    extends _$AppointmentStateCopyWithImpl<$Res, _$CancelledImpl>
    implements _$$CancelledImplCopyWith<$Res> {
  __$$CancelledImplCopyWithImpl(
      _$CancelledImpl _value, $Res Function(_$CancelledImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CancelledImpl implements Cancelled {
  const _$CancelledImpl();

  @override
  String toString() {
    return 'AppointmentState.cancelled()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CancelledImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) {
    return cancelled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) {
    return cancelled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) {
    return cancelled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) {
    return cancelled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled(this);
    }
    return orElse();
  }
}

abstract class Cancelled implements AppointmentState {
  const factory Cancelled() = _$CancelledImpl;
}

/// @nodoc
abstract class _$$DisconnectedImplCopyWith<$Res> {
  factory _$$DisconnectedImplCopyWith(
          _$DisconnectedImpl value, $Res Function(_$DisconnectedImpl) then) =
      __$$DisconnectedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DisconnectedImplCopyWithImpl<$Res>
    extends _$AppointmentStateCopyWithImpl<$Res, _$DisconnectedImpl>
    implements _$$DisconnectedImplCopyWith<$Res> {
  __$$DisconnectedImplCopyWithImpl(
      _$DisconnectedImpl _value, $Res Function(_$DisconnectedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DisconnectedImpl implements Disconnected {
  const _$DisconnectedImpl();

  @override
  String toString() {
    return 'AppointmentState.disconnected()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DisconnectedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) {
    return disconnected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) {
    return disconnected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) {
    if (disconnected != null) {
      return disconnected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) {
    return disconnected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) {
    return disconnected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) {
    if (disconnected != null) {
      return disconnected(this);
    }
    return orElse();
  }
}

abstract class Disconnected implements AppointmentState {
  const factory Disconnected() = _$DisconnectedImpl;
}

/// @nodoc
abstract class _$$NoShowImplCopyWith<$Res> {
  factory _$$NoShowImplCopyWith(
          _$NoShowImpl value, $Res Function(_$NoShowImpl) then) =
      __$$NoShowImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoShowImplCopyWithImpl<$Res>
    extends _$AppointmentStateCopyWithImpl<$Res, _$NoShowImpl>
    implements _$$NoShowImplCopyWith<$Res> {
  __$$NoShowImplCopyWithImpl(
      _$NoShowImpl _value, $Res Function(_$NoShowImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoShowImpl implements NoShow {
  const _$NoShowImpl();

  @override
  String toString() {
    return 'AppointmentState.noShow()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoShowImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pending,
    required TResult Function() confirmed,
    required TResult Function() active,
    required TResult Function() ongoing,
    required TResult Function() missed,
    required TResult Function() requestForReschedule,
    required TResult Function() partiallyCompleted,
    required TResult Function() completed,
    required TResult Function() cancelled,
    required TResult Function() disconnected,
    required TResult Function() noShow,
  }) {
    return noShow();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pending,
    TResult? Function()? confirmed,
    TResult? Function()? active,
    TResult? Function()? ongoing,
    TResult? Function()? missed,
    TResult? Function()? requestForReschedule,
    TResult? Function()? partiallyCompleted,
    TResult? Function()? completed,
    TResult? Function()? cancelled,
    TResult? Function()? disconnected,
    TResult? Function()? noShow,
  }) {
    return noShow?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pending,
    TResult Function()? confirmed,
    TResult Function()? active,
    TResult Function()? ongoing,
    TResult Function()? missed,
    TResult Function()? requestForReschedule,
    TResult Function()? partiallyCompleted,
    TResult Function()? completed,
    TResult Function()? cancelled,
    TResult Function()? disconnected,
    TResult Function()? noShow,
    required TResult orElse(),
  }) {
    if (noShow != null) {
      return noShow();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Pending value) pending,
    required TResult Function(Confirmed value) confirmed,
    required TResult Function(Active value) active,
    required TResult Function(Ongoing value) ongoing,
    required TResult Function(Missed value) missed,
    required TResult Function(RequestForReschedule value) requestForReschedule,
    required TResult Function(PartiallyCompleted value) partiallyCompleted,
    required TResult Function(Completed value) completed,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(NoShow value) noShow,
  }) {
    return noShow(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Pending value)? pending,
    TResult? Function(Confirmed value)? confirmed,
    TResult? Function(Active value)? active,
    TResult? Function(Ongoing value)? ongoing,
    TResult? Function(Missed value)? missed,
    TResult? Function(RequestForReschedule value)? requestForReschedule,
    TResult? Function(PartiallyCompleted value)? partiallyCompleted,
    TResult? Function(Completed value)? completed,
    TResult? Function(Cancelled value)? cancelled,
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(NoShow value)? noShow,
  }) {
    return noShow?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Pending value)? pending,
    TResult Function(Confirmed value)? confirmed,
    TResult Function(Active value)? active,
    TResult Function(Ongoing value)? ongoing,
    TResult Function(Missed value)? missed,
    TResult Function(RequestForReschedule value)? requestForReschedule,
    TResult Function(PartiallyCompleted value)? partiallyCompleted,
    TResult Function(Completed value)? completed,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Disconnected value)? disconnected,
    TResult Function(NoShow value)? noShow,
    required TResult orElse(),
  }) {
    if (noShow != null) {
      return noShow(this);
    }
    return orElse();
  }
}

abstract class NoShow implements AppointmentState {
  const factory NoShow() = _$NoShowImpl;
}
